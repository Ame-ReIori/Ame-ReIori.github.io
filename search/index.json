[{"content":"Background \u0026amp; Motivation 文章针对三方场景下的安全排序和安全选择问题，对于研究的问题，informal的描述如下：\n安全排序： 各个参与方持有一个secret shared的列表，这个列表中有$n$个元素（这些元素可能还有相关联的payload），他们最终得到secret shared的排序后的列表（以及对应的payload） 安全选择： 依旧是上面这样设置的列表，参与方最终得到的是secret shared的第$k$个ranked element 在场景设置上，文章考虑了两种三方场景，一种是3-party，另一种是(2+1)-party。后面一个也是在基于FSS的方案中非常常见的场景，一个party会充当dealer，仅会在offline阶段给其他两个party发送一些correlated randomness来辅助online的计算。\n对于各个参与方的输入，虽然总的参与方数量都是3个，但输入的列表都是在两方之间进行share的。\n文章的Motivation是说，目前的方案要么通信复杂度非常高，要么轮复杂度非常高，远达不到optimal的程度，他们希望给出同时在online communication和round上达到near-optimal的方案。\nTheir Idea 首先从明文下的排序算法出发，它可以分为两个阶段：Ranking和Routing。在Ranking阶段计算每个元素的Rank，其中Rank被定义为比该元素小$(\u003c)$的元素数量；在Routing阶段，根据上一阶段计算得到的Rank对元素进行重排或选择（对应排序任务和选择任务）。因此，他们的idea就是通过安全地实现上面两个阶段，进行组合就可以得到安全排序协议或安全选择协议。\n文章借助了FSS这一技术所提供的两个性质：\nFSS的输出是线性的，可以在本地直接进行聚合； 近年提出的一种新的FSS可以输出RSS形式的output，RSS可以在三方场景下无交互地进行一次乘法 在这样的想法下，文章针对Ranking和Routing给出了两种安全计算协议，他们之间可以组合从而形成安全排序和安全选择协议。因此本文的贡献可以罗列如下：\nFSS-based Ranking 文章基于DCF和DPF分别给出了一种安全Ranking的协议，这里简单介绍他们的idea是什么，具体的思考会放在后面。\nDCF-based Ranking (CmpAgg) Ranking是在计算每个元素$x$的Rank，因此只要将$x$与其他元素$y$两两进行比较，如果$y\\leq x$，那么输出1的share，否则输出0的share，再将所有的share累加即可。而比较这个事情，在FSS中可以通过DCF来很容易地实现。\n具体来说，给定一个列表$\\{x_1, \\dots, x_n\\}$的share和列表$\\{r_1, \\dots, r_n\\}$的share，参与方可以通过一轮交互来公开一个masked列表$\\{x_1',\\dots,x_n'\\}$。之后，参与方使用DCF来对这个列表中的元素两两之间进行安全比较。对于元素$x_i$，$\\textsf{Rank}(x_i)$为所有和$x_i$相关的两两比较的结果之和。注意到，DCF运行在两方场景下，需要一个dealer来分发密钥，因此该方案运行在(2+1)-party下。\nDPF-based Ranking (mult-DPF) 对于给定的列表$\\{x_1,\\dots, x_n\\}$的share，使用DPF可以给出该列表的histogram. 简单来说，对于元素$x$，构造$f_{r,1}$的DPF。该DPF可以产生一个unit vector $\\boldsymbol{u}_r$，它在第$r$个位置上为1的share，其他位置上为0的share。参与方可以获得一个$x$的masked值$x'=x+r$，将$\\boldsymbol{u}_{r}$左移$x'$即可得到$\\boldsymbol{u}_x$. 对于每一个$x_i$都进行这样的操作，得到$\\boldsymbol{u}_i$并进行累加得到$\\boldsymbol{v}$，$\\boldsymbol{v}$就是该列表的histogram.\n$$ \\textsf{Rank}(x_i) = n - \\boldsymbol{u}_i\\cdot \\boldsymbol{w} $$ 进一步的，我们想要实现stable的ranking，可以通过简单的修改完成。令$\\boldsymbol{y}_i=\\sum_{j=1}^{i-1}\\boldsymbol{u}_i$，那么$\\boldsymbol{y}_i\\cdot \\boldsymbol{u}_i$代表了$x_k=x_i$且$k","date":"2025-01-05T16:47:41+08:00","permalink":"https://ame-reiori.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBsecure-sorting-and-selection-via-function-secret-sharing/","title":"论文阅读|Secure Sorting and Selection via Function Secret Sharing"}]